// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using news;
//
//    var hirek = Hirek.FromJson(jsonString);

namespace news
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Hirek
    {
        public string Title { get; set; }
        public DateTime Date { get; set; }

        public Hirek(string title, DateTime date)
        {
            Title = title;
            Date = date;
        }
        public Hirek() { }

        [JsonProperty("totalItems")]
        public long TotalItems { get; set; }

        [JsonProperty("endIndex")]
        public long EndIndex { get; set; }

        [JsonProperty("startIndex")]
        public long StartIndex { get; set; }

        [JsonProperty("itemsPerPage")]
        public long ItemsPerPage { get; set; }

        [JsonProperty("items")]
        public Item[] Items { get; set; } 
    }

    public partial class Item
    {
        public DateTime Date { get; set; }

        public Item(string title, DateTime date)
        {
            Title = title;
            Date = date;
        }
        [JsonProperty("essay")]
        public object[] Essay { get; set; }

        [JsonProperty("place_of_publication")]
        public string PlaceOfPublication { get; set; }

        [JsonProperty("start_year")]
        public long StartYear { get; set; }

        [JsonProperty("publisher")]
        public string Publisher { get; set; }

        [JsonProperty("county")]
        public County?[] County { get; set; }

        [JsonProperty("edition")]
        public string Edition { get; set; }

        [JsonProperty("frequency")]
        public string Frequency { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("subject")]
        public string[] Subject { get; set; }

        [JsonProperty("city")]
        public City[] City { get; set; }

        [JsonProperty("language")]
        public Language[] Language { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("holding_type")]
        public HoldingType[] HoldingType { get; set; }

        [JsonProperty("end_year")]
        public long EndYear { get; set; }

        [JsonProperty("alt_title")]
        public string[] AltTitle { get; set; }

        [JsonProperty("note")]
        public string[] Note { get; set; }

        [JsonProperty("lccn")]
        public string Lccn { get; set; }

        [JsonProperty("state")]
        public Country[] State { get; set; }

        [JsonProperty("place")]
        public string[] Place { get; set; }

        [JsonProperty("country")]
        public Country Country { get; set; }

        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("title_normal")]
        public string TitleNormal { get; set; }

        [JsonProperty("oclc")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Oclc { get; set; }
    }

    public enum City { Napa, Oakland, Petaluma, SanFrancisco, SanLeandro, SantaRosa, Vallejo };

    public enum Country { California, Maryland };

    public enum County { Alameda, Garrett, Napa, SanFrancisco, Solano, Sonoma };

    public enum HoldingType { MicrofilmMaster, MicrofilmPrintMaster, MicrofilmServiceCopy, OnlineResource, Original, Unspecified };

    public enum Language { Chinese, English, Japanese, Spanish, Swedish };

    public enum TypeEnum { Title };

    public partial class Hirek
    {
        public static Hirek FromJson(string json) => JsonConvert.DeserializeObject<Hirek>(json, news.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Hirek self) => JsonConvert.SerializeObject(self, news.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CityConverter.Singleton,
                CountryConverter.Singleton,
                CountyConverter.Singleton,
                HoldingTypeConverter.Singleton,
                LanguageConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(City) || t == typeof(City?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Napa":
                    return City.Napa;
                case "Oakland":
                    return City.Oakland;
                case "Petaluma":
                    return City.Petaluma;
                case "San Francisco":
                    return City.SanFrancisco;
                case "San Leandro":
                    return City.SanLeandro;
                case "Santa Rosa":
                    return City.SantaRosa;
                case "Vallejo":
                    return City.Vallejo;
            }
            throw new Exception("Cannot unmarshal type City");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (City)untypedValue;
            switch (value)
            {
                case City.Napa:
                    serializer.Serialize(writer, "Napa");
                    return;
                case City.Oakland:
                    serializer.Serialize(writer, "Oakland");
                    return;
                case City.Petaluma:
                    serializer.Serialize(writer, "Petaluma");
                    return;
                case City.SanFrancisco:
                    serializer.Serialize(writer, "San Francisco");
                    return;
                case City.SanLeandro:
                    serializer.Serialize(writer, "San Leandro");
                    return;
                case City.SantaRosa:
                    serializer.Serialize(writer, "Santa Rosa");
                    return;
                case City.Vallejo:
                    serializer.Serialize(writer, "Vallejo");
                    return;
            }
            throw new Exception("Cannot marshal type City");
        }

        public static readonly CityConverter Singleton = new CityConverter();
    }

    internal class CountryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Country) || t == typeof(Country?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "California":
                    return Country.California;
                case "Maryland":
                    return Country.Maryland;
            }
            throw new Exception("Cannot unmarshal type Country");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Country)untypedValue;
            switch (value)
            {
                case Country.California:
                    serializer.Serialize(writer, "California");
                    return;
                case Country.Maryland:
                    serializer.Serialize(writer, "Maryland");
                    return;
            }
            throw new Exception("Cannot marshal type Country");
        }

        public static readonly CountryConverter Singleton = new CountryConverter();
    }

    internal class CountyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(County) || t == typeof(County?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Alameda":
                    return County.Alameda;
                case "Garrett":
                    return County.Garrett;
                case "Napa":
                    return County.Napa;
                case "San Francisco":
                    return County.SanFrancisco;
                case "Solano":
                    return County.Solano;
                case "Sonoma":
                    return County.Sonoma;
            }
            throw new Exception("Cannot unmarshal type County");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (County)untypedValue;
            switch (value)
            {
                case County.Alameda:
                    serializer.Serialize(writer, "Alameda");
                    return;
                case County.Garrett:
                    serializer.Serialize(writer, "Garrett");
                    return;
                case County.Napa:
                    serializer.Serialize(writer, "Napa");
                    return;
                case County.SanFrancisco:
                    serializer.Serialize(writer, "San Francisco");
                    return;
                case County.Solano:
                    serializer.Serialize(writer, "Solano");
                    return;
                case County.Sonoma:
                    serializer.Serialize(writer, "Sonoma");
                    return;
            }
            throw new Exception("Cannot marshal type County");
        }

        public static readonly CountyConverter Singleton = new CountyConverter();
    }

    internal class HoldingTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HoldingType) || t == typeof(HoldingType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Microfilm Master":
                    return HoldingType.MicrofilmMaster;
                case "Microfilm Print Master":
                    return HoldingType.MicrofilmPrintMaster;
                case "Microfilm Service Copy":
                    return HoldingType.MicrofilmServiceCopy;
                case "Online Resource":
                    return HoldingType.OnlineResource;
                case "Original":
                    return HoldingType.Original;
                case "Unspecified":
                    return HoldingType.Unspecified;
            }
            throw new Exception("Cannot unmarshal type HoldingType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HoldingType)untypedValue;
            switch (value)
            {
                case HoldingType.MicrofilmMaster:
                    serializer.Serialize(writer, "Microfilm Master");
                    return;
                case HoldingType.MicrofilmPrintMaster:
                    serializer.Serialize(writer, "Microfilm Print Master");
                    return;
                case HoldingType.MicrofilmServiceCopy:
                    serializer.Serialize(writer, "Microfilm Service Copy");
                    return;
                case HoldingType.OnlineResource:
                    serializer.Serialize(writer, "Online Resource");
                    return;
                case HoldingType.Original:
                    serializer.Serialize(writer, "Original");
                    return;
                case HoldingType.Unspecified:
                    serializer.Serialize(writer, "Unspecified");
                    return;
            }
            throw new Exception("Cannot marshal type HoldingType");
        }

        public static readonly HoldingTypeConverter Singleton = new HoldingTypeConverter();
    }

    internal class LanguageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Language) || t == typeof(Language?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Chinese":
                    return Language.Chinese;
                case "English":
                    return Language.English;
                case "Japanese":
                    return Language.Japanese;
                case "Spanish":
                    return Language.Spanish;
                case "Swedish":
                    return Language.Swedish;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Language)untypedValue;
            switch (value)
            {
                case Language.Chinese:
                    serializer.Serialize(writer, "Chinese");
                    return;
                case Language.English:
                    serializer.Serialize(writer, "English");
                    return;
                case Language.Japanese:
                    serializer.Serialize(writer, "Japanese");
                    return;
                case Language.Spanish:
                    serializer.Serialize(writer, "Spanish");
                    return;
                case Language.Swedish:
                    serializer.Serialize(writer, "Swedish");
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "title")
            {
                return TypeEnum.Title;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            if (value == TypeEnum.Title)
            {
                serializer.Serialize(writer, "title");
                return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
